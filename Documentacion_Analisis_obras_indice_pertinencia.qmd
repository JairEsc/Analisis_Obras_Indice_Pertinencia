---
title: "Documentación Análisis de Pertinencia de Obras Carreteras"
author: "Jair"
format: 
  html:
    page-layout: full
editor: visual
---

## Lista de consideraciones

-   Accesibilidad carretera a cabeceras municipales

-   Distancia a Escuelas

-   Distancia a Centros de Trabajo

-   Distancia a Hospitales

-   Áreas Naturales Protegidas (Distancia)

-   Zonas Prioritarias (Distancia)

-   Secciones Electorales (Prioritarias)

-   Nivel de uso

-   Distancia a localidades Marginadas (Alta y Muy alta)

-   Distancia a localidades con bajo acceso a agua entubada

-   Distancia a localidades con bajo acceso a drenaje sanitario

## Preprocesamiento y exploración

Se definen rasters

```{r}
#| echo: false
#| message: false
#| warning: false
#| include: true
library(raster)
library(viridis)
library(htmlwidgets)
library(slickR)
source("Códigos/leer_rasters_generados_en_r.R")
raster_plots <- list()
  for (i in 1:length(rasters)){
    # Crear un archivo PNG temporal para cada gráfico
    temp_file <- tempfile(fileext = ".png")
    png(temp_file, width = 600, height = 400)
    plot(rasters[[i]],
         col = viridis(256),
         legend = TRUE,main=rasters_list_names[i])
    dev.off()
    raster_plots[[i]] <- temp_file
  }
slickR(raster_plots,width = "90%")+ 
  settings(
    dots = TRUE
  )
```

Agregamos un widget para la exploración de algunos de los rasters utilizados y obras de tipo línea y punto

```{r}
#| include: false
#| warning: false
#| message: false
library(sf)
source("Códigos/leer_obras_sipdus_carretera_y_separar_por_tipo_geometria.R")
```

```{r}
#| include: false
#| echo: false
#| message: false
#| warning: false

#library(crosstalk)
library(leaflet)
library(DT)
#library(dplyr)
#library(reactable)

#obras_sipdus_carretera_multipunto es un sf de puntos
#obras_sipdus_carretera_multilinea es un sf de lineas

# SharedData_multipoint =SharedData$new(obras_sipdus_carretera_multipunto|> as("Spatial"), group = "obras_sipdus")
#  SharedData_multilinea <- SharedData$new(obras_sipdus_carretera_linea  |> as("Spatial"), group = "obras_sipdus")

#SharedData_multilinea+SharedData_multipoint deberían ser un mismo SharedData tipo lista y que se pueda acceder a cada uno como SharedData[[1]] y SharedData[[2]]

# A regular data frame (without coordinates) for the table.
# obras_sipdus_tabla <- as_tibble(
#   obras_sipdus_carretera#Notar que este incluye tanto lineas como puntos
#                                 )|> dplyr::select(ID_OBRA,Municipio,Rubro,Ejercicio,
#                                                                             #Obra,
#                                                                             Inversión,Habitantes.beneficiados,Ejecutora,Geometria_tipo) |> 
#   SharedData$new(group = "obras_sipdus")
# 
# map <- leaflet() |> addTiles(options = leaflet::tileOptions(opacity = 0.5)) |> 
#   addRasterImage(rasters[[1]],opacity = 0.5,group = "Accesibilidad") |>
#   addRasterImage(rasters[[2]],opacity = 0.5,group = "Distancia centros de trabajo") |>
#   addRasterImage(rasters[[3]],opacity = 0.5,group = "Distancia áreas naturales protegidas") |>
#   addRasterImage(rasters[[4]],opacity = 0.5,group = "Distancia Escuelas") |>
#   addRasterImage(rasters[[5]],opacity = 0.5,group = "Distancia Hospitales") |>
#   addRasterImage(rasters[[6]],opacity = 0.5,group = "Distancia a localidades marginadas") |>
#   addRasterImage(rasters[[7]],opacity = 0.5,group = "Distancia a ZAP") |>
#   addPolylines(data=SharedData_multilinea
#                ,group = "Obras_tipo_linea"
#                ,label = obras_sipdus_carretera_linea$Obra
#   ) |>
#   # addMarkers(data=obras_sipdus_carretera_punto,group = "Obras_tipo_punto",
#   #            label = obras_sipdus_carretera_punto$Obra) |>
#   addMarkers(data=SharedData_multipoint,group = "Obras_tipo_multipunto",
#              label = obras_sipdus_carretera_multipunto$Obra) |>
#   addLayersControl(overlayGroups = c("Accesibilidad",
#                                      "Distancia centros de trabajo",
#                                      "Distancia áreas naturales protegidas",
#                                      "Distancia Escuelas",
#                                      "Distancia Hospitales",
#                                      "Distancia a localidades marginadas",
#                                      "Distancia a ZAP"
#                                      ,"Obras_tipo_linea","Obras_tipo_multilinea","Obras_tipo_multipunto"))
# 
# tbl <- reactable(
#   obras_sipdus_tabla,
#   selection = "multiple",
#   onClick = "select",
#   rowStyle = list(cursor = "pointer"),
#   minRows = 10,filterable = T,showPageSizeOptions = T,highlight = T,striped = T,showSortIcon = T
# )
# 
# htmltools::browsable(
#   htmltools::tagList(map, tbl)
# )

```

```{r}
#| include: true
#| echo: false
#| message: false
#| warning: false
library(leaflegend)
leaflet() |> addTiles(options = leaflet::tileOptions(opacity = 0.5)) |>
  addRasterImage(rasters[[1]],opacity = 0.4,group = "Accesibilidad") |>
  addRasterImage(rasters[[2]],opacity = 0.4,group = "Distancia centros de trabajo") |>
  addRasterImage(rasters[[3]],opacity = 0.4,group = "Distancia áreas naturales protegidas") |>
  addRasterImage(rasters[[4]],opacity = 0.4,group = "Distancia Escuelas") |>
  addRasterImage(rasters[[5]],opacity = 0.4,group = "Distancia Hospitales") |>
  addRasterImage(rasters[[6]],opacity = 0.4,group = "Distancia a localidades marginadas") |>
  addRasterImage(rasters[[7]],opacity = 0.4,group = "Distancia a ZAP") |>
  addRasterImage(rasters[[8]],opacity = 0.4,group = "Dist. loc. bajo acceso agua entubada") |>
  addRasterImage(rasters[[9]],opacity = 0.4,group = "Dist. loc. bajo acceso drenaje") |>
  addRasterImage(rasters[[10]],opacity = 0.4,group = "Secciones electorales") |>
  addPolylines(data=obras_sipdus_carretera_linea
               ,group = "Obras_tipo_linea"
               ,label = obras_sipdus_carretera_linea$Obra
  ) |>
  # addMarkers(data=obras_sipdus_carretera_punto,group = "Obras_tipo_punto",
  #            label = obras_sipdus_carretera_punto$Obra) |>
  addMarkers(data=obras_sipdus_carretera_multipunto,group = "Obras_tipo_multipunto",
             label = obras_sipdus_carretera_multipunto$Obra) |>
  addLayersControl(overlayGroups = c("Accesibilidad",
                                     "Distancia centros de trabajo",
                                     "Distancia áreas naturales protegidas",
                                     "Distancia Escuelas",
                                     "Distancia Hospitales",
                                     "Distancia a localidades marginadas",
                                     "Distancia a ZAP","Dist. loc. bajo acceso agua entubada","Dist. loc. bajo acceso drenaje","Secciones electorales",
                                     "Obras_tipo_linea","Obras_tipo_multipunto")) |> addLegendNumeric( pal = colorNumeric('Spectral', 1:100) , values = 1:100, position = 'bottomright', title = 'Valores de rasters', orientation = 'horizontal', shape = 'rect', decreasing = FALSE, height = 20, width = 100,labels = '',tickLength = 0) 
```

```{r}
#| echo: false
library(DT)
datatable(obras_sipdus_carretera |> 
            dplyr::select(ID_OBRA, Municipio, Rubro, Ejercicio, Inversión, Habitantes.beneficiados, Ejecutora, Obra) |> 
            st_drop_geometry() |> 
            dplyr::rename(Habitantes_beneficiados=Habitantes.beneficiados), 
          options = list(
            rownames = FALSE,
            columnDefs = list(list(width = '400px', targets = c(7))),
            scrollX = TRUE,
            stripeClasses = c('even', 'odd')
          ),
          filter = "top")

```

De todas maneras, aún debemos establecer la interpretación de cada raster, hacer un escalamiento apropiado y definir los pesos de cada raster que definirán la pertinencia de obras.

```{r}
#| echo: false
#| message: false
#| warning: false
#| include: false
library(raster)
library(viridis)
library(htmlwidgets)
library(slickR)
rasters_list_names_interpretaciones=rasters_list_names |> as.list()
rasters_list_names_interpretaciones[[1]]=paste0(rasters_list_names_interpretaciones[[1]],
          "-------\n Dado que la distancia se mide en minutos, mayor valor de accesibilidad indica lugares de difícil acceso, en tal caso, un valor alto de accesibilidad indica más pertinencia de obras carreteras.")

rasters_list_names_interpretaciones[[2]]=paste0(rasters_list_names_interpretaciones[[2]],
          "-------\n Una distancia corta a centros de trabajo se interpreta como un incentivo a la productividad local, fortaleciendo su acceso y su movilidad. En este caso, la interpretación de distancia sería inversa a la pertinencia.")

rasters_list_names_interpretaciones[[3]]=paste0(rasters_list_names_interpretaciones[[3]],
          "-------\n Aunque no todas las ANP tienen carácter restictivo, la norma general es la preservación por lo que menor distancia a una ANP debería ser interpretado como baja pertinencia")
rasters_list_names_interpretaciones[[4]]=paste0(rasters_list_names_interpretaciones[[4]],
          "-------\n La interpretación es equivalente a la de centros de trabajo. Obras de infraestructura carretera y vialidades urbanas cerca de escuelas se interpreta como un refuerzo a su accesibilidad y movilidad. En este caso, la interpretación de distancia sería inversa a la pertinencia.")
rasters_list_names_interpretaciones[[5]]=paste0(rasters_list_names_interpretaciones[[5]],
          "-------\n La interpretación es equivalente a la de centros de trabajo y escuelas. Obras de infraestructura carretera y vialidades urbanas cerca de hospitales y centros de salud se interpreta como un refuerzo a su accesibilidad y movilidad. En este caso, la interpretación de distancia sería inversa a la pertinencia.")
rasters_list_names_interpretaciones[[6]]=paste0(rasters_list_names_interpretaciones[[6]],
          "-------\n Dado que tenemos identificadas las localidades (polígonos y puntos) de alto y muy alto grado de marginación, se puede establecer la medida del grado de marginación en los asentamientos humanos en general, y la distancia de una obra al asentamiento dado. En tal caso, la distancia de las localidades marginadas sería inversa a la pertinencia.")
rasters_list_names_interpretaciones[[7]]=paste0(rasters_list_names_interpretaciones[[7]],
          "-------\n La interpretación de las zonas de atención prioritaria es equivalente a la de localidades marginadas, con la diferencia de utilizar diferentes criterios para determinar la clasificación de cada zona. En tal caso, la distancia de las zonas de atención prioritaria sería inversa a la pertinencia.")
rasters_list_names_interpretaciones[[8]]=paste0(rasters_list_names_interpretaciones[[8]],
          "-------\n Bajo acceso a agua entubada y acceso a drenaje sanitario se definen a partir de límites inferiores dados por cuantiles de los datos a nivel de localidad. Posteriormente se calcula la distancia a las localidades. En tal caso, un valor bajo indica una mayor pertinencia, pues está relacionado a localidades en carencia. ")
rasters_list_names_interpretaciones[[9]]=paste0(rasters_list_names_interpretaciones[[9]],
          "-------\n Bajo acceso a agua entubada y acceso a drenaje sanitario se definen a partir de límites inferiores dados por cuantiles de los datos a nivel de localidad. Posteriormente se calcula la distancia a las localidades. En tal caso, un valor bajo indica una mayor pertinencia, pues está relacionado a localidades en carencia. ")
rasters_list_names_interpretaciones[[10]]=paste0(rasters_list_names_interpretaciones[[10]],
          "-------\n Para las secciones electorales, se aprovecha el hecho de definir una partición geográfica. En este caso se calcula el porcentaje de votos al partido por cada sección para definir el raster. La interpretación natural es el de incentivar, ya sea para reforzar votos futuros en secciones ya ganadas, o para lograr un porcentaje mayor en secciones perdidas. ")


```

```{r}
#| echo: false
#| message: false
#| warning: false
#| include: true
library(raster)
library(viridis)
library(htmlwidgets)
library(slickR)
library(grid)
library(ggplot2)
raster_plots <- list()
for (i in 1:length(rasters)){
  temp_file <- tempfile(fileext = ".png")
  png(temp_file, width = 600, height = 400)
  plot(rasters[[i]], col = viridis(256), legend = TRUE, main = rasters_list_names[i])
  
  hist_plot <- ggplot(data.frame(x = getValues(rasters[[i]])), aes(x)) +
    geom_histogram(bins = 30, fill = viridis(1), color = "white") +
    theme_minimal() +
    labs(x = "", y = "") +
    theme(
      plot.background = element_rect(fill = "white", color = NA),
      panel.background = element_rect(fill = "white", color = NA)
    )
  
  vp <- viewport(width = 0.3, height = 0.3, x = 0, y = 0, just = c("left", "bottom"))
  print(hist_plot, vp = vp)
  dev.off()
  raster_plots[[i]] <- temp_file
}

slickR(raster_plots,height = "80vh",width = "90%")%synch%
( slickR(rasters_list_names_interpretaciones, slideType = 'p'))+
  settings(
    dots = TRUE,adaptiveHeight = T
  )
```

Podemos explorar algunas correlaciones entre los raster utilizados

```{r}
#| echo: false
library(ggcorrplot)

rasters_by_cells <- rasters |> lapply(getValues)
rasters_by_cells=rasters_by_cells |> as.data.frame()
colnames(rasters_by_cells)=gsub("\n","",rasters_list_names)
cormat <- round(cor(rasters_by_cells,use = "na"),2)
#head(cormat)
ggcorrplot(cormat,lab = T)

```

Y también visualizarlas por pares.

```{r}
#| echo: false

library(raster)
library(viridis)
library(htmltools)
library(slickR)

###Agregarlos en un div con display flex.
div(
  style = "display: flex;",
  div(
    style = "width: 47.5%;",
    slickR(raster_plots) +
      settings(dots = TRUE)
  ),
  div(
    style = "width: 47.5%;padding-left:5%",
    slickR(raster_plots[c(2:10)]) +
      settings(dots = TRUE)
  )
)

```

Esta información se toma en cuenta al momento de definir los rankings en el método de las jerarquías analíticas.

# Criterios de Clasificación

Definimos dos tipos de obra, ***Mejoramiento*** y ***Construcción.*** En la primera se agregan aquellas obras que consisten en remodelación, reconstrucción, repavimentación o mejoramiento de obras ya existentes.

## ***Mejoramiento***

Para la definición de la pertinencia de una obra ya existente se considerarán únicamente los criterios de Accesibilidad y una medida de uso definida a partir de datos de orígenes destino, los cuales están definidos únicamente para vialidades.

```{r}
#| echo: false

###Agregarlos en un div con display flex.
div(
  style = "display: flex;",
  div(
    style = "width: 45%;",
    plot(rasters[[1]],
         col = viridis(256),
         legend = TRUE,main=rasters_list_names[1])
  ),
  div(
    style = "width: 45%;padding-left:5%",
    plot("Inputs/Rasters_Generados_en_R/Otros/nivel_de_uso_proxy_de_numero_de_viajes.tif" |> raster(),
         col = viridis(256),
         legend = TRUE,main="Nivel de uso")
  )
)
```

## Construcción

Para definir la pertinencia de una obra nueva, se utilizarán los criterios anteriormente enunciados, a partir del siguiente ranking.

-   <div>

    1.  Accesibilidad carretera a cabeceras municipales

    </div>

-   <div>

    2.  Distancia a localidades Marginadas (Alta y Muy alta)

    </div>

-   <div>

    3.  Zonas Prioritarias (Distancia)

    </div>

-   <div>

    4.  Distancia a localidades con bajo acceso a agua entubada y Distancia a localidades con bajo acceso a drenaje sanitario

    </div>

-   <div>

    5.  Distancia a Hospitales

    </div>

-   <div>

    6.  Distancia a Escuelas

    </div>

-   <div>

    7.  Distancia a Centros de Trabajo

    </div>

-   <div>

    8.  Áreas Naturales Protegidas (Distancia)

    </div>

-   <div>

    9.  Secciones Electorales (Prioritarias)

    </div>

# Clasificación

## Contrucción

Antes de definir el índice de pertinencia removemos valores atípicos para cada raster basados en el criterio del rango intercuartil. Estos valores atípicos se reemplazan con los valores máximos o mínimos de los valores no atípicos, según sea el caso.

Además, dada la alta correlación entre distancia a localidades con bajo acceso a agua entubada y drenaje, se combinan en un solo raster dado por el mínimo entre ellos.

```{r}
#| echo: false

library(raster)
library(viridis)
library(htmltools)
library(slickR)
rasters[[8]]=min(rasters[[8]],rasters[[9]],na.rm = T)
rasters=rasters[c(1:8,10)]
rasters_list_names[8]='Distancia a localidades con bajo acceso a agua entubada o drenaje sanitario'
rasters_list_names=rasters_list_names[c(1:8,10)]
for(i in 1:length(rasters)){
  raster_vals <- values(rasters[[i]])
  raster_vals <- raster_vals[!is.na(raster_vals)]
  
  q1 <- quantile(raster_vals, 0.25)
  q3 <- quantile(raster_vals, 0.75)
  iqr <- q3 - q1
  
  upper_limit <- q3 + 1.5 * iqr
  lower_limit <- q1 - 1.5 * iqr
  
  rasters[[i]] <- clamp(rasters[[i]], 
                        lower = lower_limit, 
                        upper = upper_limit, 
                        useValues=TRUE)
}


raster_plots <- list()
  for (i in 1:length(rasters)){
    # Crear un archivo PNG temporal para cada gráfico
    temp_file <- tempfile(fileext = ".png")
    png(temp_file, width = 600, height = 400)
    plot(rasters[[i]],
         col = viridis(256),
         legend = TRUE,main=rasters_list_names[i])
    dev.off()
    raster_plots[[i]] <- temp_file
  }

###Agregarlos en un div con display flex.
div(
  style = "display: flex;",
  div(
    style = "width: 47.5%;",
    slickR(raster_plots) +
      settings(dots = TRUE)
  ),
  div(
    style = "width: 47.5%;padding-left:5%",
    slickR(raster_plots[c(2:9)]) +
      settings(dots = TRUE)
  )
)

```

Con los rankings de criterios definimos una transformación lineal con los criterios y su interpretación

```{r}
#| echo: false
current_rasters=rasters
current_rasters_list_names=rasters_list_names
origin(current_rasters[[1]])=origin(current_rasters[[2]])
extent(current_rasters[[1]])=extent(current_rasters[[2]])
weights=c(9,3,2,4,5,8,7,6,1)
weights=weights/sum(weights)
weights[1]=-weights[1]
weights=-weights

current_rasters= current_rasters|> sapply(scale,simplify = T,USE.NAMES = F)
(current_rasters[[1]]*weights[1]+current_rasters[[2]]*weights[2]+
  current_rasters[[3]]*weights[3]+current_rasters[[4]]*weights[4]+
  current_rasters[[5]]*weights[5]+current_rasters[[6]]*weights[6]+
  current_rasters[[7]]*weights[7]+current_rasters[[8]]*weights[8]+
  current_rasters[[9]]*weights[9])->z_sum

leaflet() |> addTiles() |> addRasterImage(z_sum)|> addLegendNumeric( pal = colorNumeric('Spectral', 1:100) , values = 1:100, position = 'bottomright', title = 'Valores de rasters', orientation = 'horizontal', shape = 'rect', decreasing = FALSE, height = 20, width = 100,labels = '',tickLength = 0) 
```

## Mejoramiento

La superposición de las capas "Accesibilidad" y "Nivel de uso" puede parecer redundante

```{r}
div(
  style = "display: flex;",
  div(
    style = "width: 47.5%;",
    plot(rasters[[1]])
  ),
  div(
    style = "width: 47.5%;padding-left:5%",
    plot("Inputs/Rasters_Generados_en_R/Otros/nivel_de_uso_proxy_de_numero_de_viajes.tif" |> raster())
  )
)
```
